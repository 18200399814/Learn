/*1.进程虚拟地址空间的创建：
 *  当我们运行磁盘上的一个可执行程序, 就会得到一个进程。内核会给每一个运行的进程创建一块属于自己的
 *  虚拟地址空间，并将应用程序数据装载到虚拟地址空间对应的地址上。虚拟地址空间的大小也由操作系统决定，
 *  32位的操作系统虚拟地址空间的大小为2^32字节，也就是4G；64位的操作系统虚拟地址空间大小为2^64字节。
 */
 
/*2.虚拟内存和物理内存的关系：
 *  进程在运行过程中，程序内部所有的指令都是通过CPU处理完成的，CPU只进行数据运算并不具备数据存储的能力，
 *  其处理的数据都加载自物理内存。进程中的数据是通过CPU中的内存管理单元MMU（Memory Management Unit）从
 *  进程的虚拟地址空间中映射到物理内存中去的。
 */

/*3.虚拟地址空间存在的意义：
 *（1）每个进程的地址不隔离，有安全风险。由于程序都是直接访问物理内存，所以恶意程序可以通过内存寻址随意
 *     修改别的进程对应的内存数据，以达到破坏的目的。虽然有些时候是非恶意的，但是有些存在bug的程序可能不
 *     小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常。
 *（2）直接使用物理内存效率低。如果直接使用物理内存的话，一个进程对应的内存块就是作为一个整体操作的，
 *     如果出现物理内存不够用的时候，我们一般的办法是将不常用的进程拷贝到磁盘的交换分区（虚拟内存）中，
 *     以便腾出内存，因此就需要将整个进程一起拷走，如果数据量大在内存和磁盘之间拷贝时间就会很长，效率低下。
 *（3）进程中数据的地址不确定，每次都会发生变化。由于物理内存的使用情况一直在动态变化，我们无法确定内存现在
 *     使用到哪里了。如果直接将程序数据加载到物理内存，内存中每次存储数据的起始地址都是不一样的，这样数据的
 *     加载都需要使用相对地址，加载效率低（静态库是使用绝对地址加载的）。
 *（4）虚拟地址空间就是一个中间层，相当于在程序和物理内存之间设置了一个屏障，将二者隔离开来。程序中访问的内存
 *     地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上。
 *     这样只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，
 *     彼此没有重叠，就可以达到内存地址空间隔离的效果。
 */

/*4.虚拟地址空间的分区：（从操作系统层级上看，虚拟地址空间主要分为两个部分内核区和用户区）
 *（1）内核区：
 *  ①内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。
 *  ②内核总是驻留在内存中，是操作系统的一部分。
 *  ③系统中所有进程对应的虚拟地址空间的内核区都会映射到同一块物理内存上（系统内核只有一个）。
 *（2）用户区：
 *  ①每个进程的虚拟地址空间都是从0地址开始的，我们在程序中打印的变量地址也其在虚拟地址空间中的地址，
 *    程序是无法直接访问物理内存的。虚拟地址空间中用户区地址范围是0~3G，里面分为多个区块。
 *  ②保留区: 位于虚拟地址空间的最底部，未赋予物理地址。任何对它的引用都是非法的，程序中的空指针NULL
 *            指向的就是这块内存地址。
 *  ③.text段: 代码段也称正文段或文本段，通常用于存放程序的执行代码（即CPU执行的机器指令），代码段一般
 *             情况下是只读的，这是对执行代码的一种保护机制。
 *  ④.data段: 数据段通常用于存放程序中已初始化，且初值不为0的全局变量和静态变量。数据段属于静态内存分配
 *             （静态存储区），可读可写。
 *  ⑤.bss段: 未初始化以及初始为0的全局变量和静态变量，操作系统会将这些未初始化变量初始化为0。
 *  ⑥堆(heap)：用于存放进程运行时动态分配的内存。堆中内容是匿名的，不能按名字直接访问，只能通过指针间接访问。
 *              堆向高地址扩展（即“向上生长”），是不连续的内存区域。这是由于系统用链表来存储空闲内存地址，
 *              自然不连续，而链表从低地址向高地址遍历。
 *  ⑦内存映射区(mmap)：作为内存映射区加载磁盘文件，或者加载程序运作过程中需要调用的动态库。
 *  ⑧栈(stack): 存储函数内部声明的非静态局部变量、函数参数、函数返回地址等信息，栈内存由编译器自动分配释放。
 *               栈和堆相反地址“向下生长”，分配的内存是连续的。
 *  ⑨命令行参数：存储进程执行的时候传递给main()函数的参数argc和argv[]。
 *  ⑩环境变量: 存储和进行相关的环境变量，比如：工作路径、进程所有者等信息。
 */

#include <unistd.h>       //write(),sleep(),getpid(),getppid(),fork(),vfork()
#include <sys/types.h>    //pid_t
#include <sys/wait.h>
#include <stdio.h>
#include <string.h>

#define BUFF_SIZE 1024

#define PRINT_INFO(str)  \
	write(STDOUT_FILENO,str,strlen(str))

int main(void)
{
	PRINT_INFO("---start main---\n");
	
	char buf[BUFF_SIZE] = {0};
	sprintf(buf,"main process id: %d\n",getpid());
	PRINT_INFO(buf);
	
	int var = 0;  //变量var在父子进程的栈空间中都存在，且在父子进程空间中的地址都相同
	
	/*fork()创建的子进程完整的拷贝了主进程的4G内存空间，包括堆栈信息、代码段和数据段，
	 *所以父子进程包含相同的运行代码、全局变量、静态变量和字符串常量。
	 */
	pid_t pid = fork();   //fork()成功后在主进程中返回子进程pid，在子进程中返回0。fork()失败返回-1
	if(pid == -1)
	{
		perror("fork error: ");
		return -1;
	}
	else if(pid > 0)   //fork()成功后父子进程都会执行这条else if(pid > 0)判断。
	{
		/*父子进程的代码段中都具有else if(pid > 0)判断的语句块，只是由于父进程中pid才大于0，
		 *所以只有父进程才能走进来，子进程由于pid等于0，所以不会执行这一段代码块。
		 */
		++var;
		int mainpid = getpid();   //获取当前进程id，由于当前进程为主进程，所以为获取主进程id
		memset(buf,0,sizeof(buf));
		sprintf(buf,"this is main process, pid =%d,mainpid =%d, var =%d, &var =%p\n",pid,mainpid,var,&var);
		
		PRINT_INFO(buf);
		var++;
	}
	else if(pid == 0)  //fork()成功后父子进程都会执行这条else if(pid = 0)判断。
	{
		/*父子进程的代码段中都具有else if(pid == 0)判断的语句块，只是由于子进程中pid才等于0，
		 *所以只有子进程才能走进来，父进程由于pid大于0，所以不会执行这一段代码块。
		 */
		++var;
		int subpid = getpid();   //获取当前进程id，由于当前进程为子进程，所以为获取子进程id
		memset(buf,0,sizeof(buf));
		sprintf(buf,"this is child process,pid =%d,subpid =%d, var =%d, &var =%p\n",pid,subpid,var,&var);
		
		PRINT_INFO(buf);
		var += 1;
	}
	
	//由于没有区分父子进程pid，所以主进程和子进程都会执行这一段代码。
	memset(buf,0,BUFF_SIZE);
	sprintf(buf,"var will print twice, var =%d, &var =%p, pid =%d, getpid() =%d\n\n",var,&var,pid,getpid());
	PRINT_INFO(buf);
	
	//阻塞主进程和子进程，方便使用ps -ef | grep helloprocess.out查看进程id
	sleep(10);
	PRINT_INFO("---end main---\n");
	
	return 0;
}