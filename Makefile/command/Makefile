#Makefile中的规则是由依赖关系规则和命令组成的。所使用的命令是由shell命令行组成，
#它们是一条一条执行的。多个命令之间要使用分号隔开，Makefile中的任何命令都要以tab键开始。
#多个命令行之间可以有空行和注释行，在执行规则时空行会被自动忽略。

#通常系统中可能存在不同的shell 。但是make处理Makefile过程时，如果没有明确的指定，
#那么对所有规则中的命令行的解析使用bin/sh来完成。执行过程中使用的shell决定了规则中的命令的语法和处理机制。
#当使用默认的bin/sh时，命令中出现的字符“#”到行末的内容被认为是注释。当然了“#”可以不在此行的行首，
#此时“#”之前的内容不会被作为注释处理。

#1.命令回显：（典型的用法是在使用echo命令输出一些信息时）
#	通常make在执行命令行之前会把要是执行的命令行输出到标准输出设备。我们称之为"回显"，
#	就好像我们在shell环境下输入命令执行时一样。如果规则的命令行以字符“@”开始，
#	则make在执行的时候就不会显示这个将要被执行的命令。

.PHONY:echo_test line_test

var := test main list
echo_test:
	echo $(var)
	@echo $(var)

#在执行make时添加上一些参数，可以控制命令行是否输出。当使用make的时候机加上参数-n或者是--just-print，
#执行时只显示所要执行的命令，但不会真正的执行这个命令。只有在这种情况下make才会打印出所有的make需要执行的命令，
#其中包括了使用的“@”字符开始的命令。这个选项对于我们调试Makefile非常的有用，使用这个选项就可以按执行顺序打印出Makefile中
#所需要执行的所有命令。而make参数-s或者是--slient则是禁止所有的执行命令的显示。就好像所有的命令行都使用“@”开始一样。

#2.命令的执行：
#当规则中的目标需要被重建的时候，此规则所定义的命令将会被执行。如果是多行的命令，
#那么每一行命令将在一个独立的子shell进程中被执行。因此多命令行之间的执行命令时是相互独立的，相互之间不存在往来。

#3.并发执行命令
#GNU make支持同时执行多条命令。通常情况下同一时刻只有一个命令在执行，下一个命令只有在当前命令结束之后才能够开始执行。
#不过可以通过make命令行选项"-j"或者"--jobs"来告诉make在同一时刻可以允许多条命令同时执行。

#如果选项"-j"之后存在一个整数，其含义是告诉make在同一时刻可以允许同时执行的命令行的数目。
#这个数字被称为job slots。当"-j"选项中没有出现数字的时候，那么同一时间执行的命令数目没有要求。
#使用默认的job solts值为1，表示make将串行的执行规则的命令（同一时刻只能由一条命令被执行）。