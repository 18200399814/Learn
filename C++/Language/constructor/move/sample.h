/*1.拷贝构造函数和移动构造函数的调用顺序：
 *（1）当传入构造函数的参数是一个左值/引用/变量时，那么会优先匹配左值引用版本的拷贝构造函数。
 *     如果类中不存在左值引用版本的拷贝构造函数，那么会继续匹配常量左值引用版本的拷贝构造函数。
 *     如果常量左值引用版本的拷贝构造函数也不存在时，那么编译器会直接报语法错误，对象不能被构造。
 *     而不会继续匹配到右值引用版本的移动构造函数。但是可以通过std::move函数将一个左值转换为右值，
 *     从而调用到移动构造函数。
 *（2）当传入构造函数的参数是一个常量左值/常量引用/const变量时，那么会优先匹配常量左值引用版本的拷贝构造函数。
 *     如果类中不存在常量左值版本的拷贝构造函数。那么就不会再往下匹配左值引用或右值引用版本的拷贝构造函数了。
 *     编译器会报语法错误，拷贝构造函数调用失败，对象构造不成功。
 *（3）当传入构造函数的参数是一个右值/临时对象时，那么会优先匹配右值引用版本的移动构造函数。
 *     如果类中不存在右值引用版本的移动构造函数，那么会继续匹配常量左值引用版本的拷贝构造函数。
 *     如果常量左值引用版本的拷贝构造函数也不存在时，那么编译器会直接报语法错误，对象不能被构造。
 *     始终不能匹配到左值引用版本的拷贝构造函数。C++中可以通过std::move将一个左值直接转化为右值，
 *     但是却没有将右值直接转化为左值的方法。
 */

/*2.拷贝构造函数和移动构造函数对比：
 *（1）左值引用版本的构造函数：允许修改传入的参数，但传入的参数必须是左值。可以实现为深拷贝、浅拷贝或移动构造函数。
 *     在C++11以前还没有移动语义的支持，auto_ptr智能指针就是通过左值引用实现的移动构造函数。
 *（2）常量左值版本的构造函数：不允许修改传入的参数，但传入的参数可以是任意类型，即传入的参数可以是左值、常量左值或右值。
 *     只能实现为深拷贝构造函数。
 *（3）右值引用版本的构造函数：允许修改传入的参数，但传入的参数必须是右值。可以实现为深拷贝、浅拷贝或移动构造函数。
 *     但右值引用版本的构造函数实现为了深拷贝或浅拷贝构造函数，那么就失去了转移右值/临时对象内存资源所有权的意义。
 */
 
 /*3.左值引用和右值引用实现的移动构造函数的比较：
  *（1）左值引用版本移动构造函数，只能接受左值/引用/变量类型参数，而不能接受右值/临时对象类型参数。且它的资源转移过程比较隐晦，
  *     用户不容易察觉。如果用户不小心继续使用了原先内存资源所有权被转移了的变量，就有可能空指针访问等问题。
  *（2）右值引用版本移动构造函数，可以接受右值/临时变量类型参数，也可以通过std::move函数接受左值/引用/变量类型参数。
  *     对于左值/引用/变量类型的参数，资源所有权的转移都要使用std::move函数，相当于显示告诉用户调用了移动构造函数。
  *     原来变量中的内存资源所有权已经发生了转移，该变量已经失效，再接下来的代码中不能再继续使用了。
  */
 
/*一般类中只需要实现常量左值引用版本的深拷贝构造函数和右值引用版本的移动构造函数就行。
 *因为左值引用版本的构造函数，如果实现为浅拷贝，那么会存在析构时同一片内存空间被多次析构问题，
 *浅拷贝方式存在固有的设计缺陷，通常类都不使用浅拷贝构造函数。如果实现为深拷贝或移动构造函数，
 *那么常量左值引用实现的深拷贝构造函数和右值引用实现的移动构造函数，都比左值引用实现得好。
 *所以类中一般不需要左值引用版本的构造函数。
 */
 
//右值引用主要用于实现移动语义和完美转发。

#ifndef _SAMPLE_H
#define _SAMPLE_H

typedef int data_t;

class Sample
{
public:
	Sample();
	Sample(const data_t data);
	Sample(const char* name,const data_t data);
	
	//左值引用&实现构造函数时，为了避免浅拷贝造成的同一内存空间在析构时被释放两次问题。也可以将其实现为
	//具有转移堆内存资源所有权功能的移动构造函数，即通过左值引用也可以实现移动构造函数/移动语义。
	Sample(Sample& other);          //左值引用&实现的浅拷贝构造函数/移动构造函数。类中一般不需要设置左值引用版本构造函数
	Sample(const Sample& other);    //常用左值引用const &实现的深拷贝构造函数。
	Sample(Sample&& other);         //右值引用&&实现的移动构造函数。
	virtual ~Sample();

	Sample& operator =(Sample& other);   //左值引用Sample&实现的浅拷贝赋值。类中一般不需要设置左值引用版本赋值运算
	Sample& operator =(const Sample& other);  //常量左值引用const Sample&实现的深拷贝赋值。
	Sample& operator =(Sample&& other);   //右值引用Sample&&实现的移动赋值。
	
	void setName(const char* name);
	const char* getName()const;
	
	void setData(const data_t data);
	data_t getData()const;
	
	void show()const;
private:
	char *name;
	data_t data;
};

#endif //_SAMPLE_H