/*1.继承了noncopyable类的派生类不能被拷贝，只能被移动。涉及拷贝的函数有两个：拷贝构造函数和拷贝复制操作符。
 *  将这两个方法声明为不可访问或者删除（=delete），即可达到不可拷贝的效果。
 *
 *2.将拷贝构造函数和拷贝复制操作符声明为private，能阻止编译器创建这两个函数，同时阻止用户调用它们，从而达到阻止拷贝的效果。
 *
 *3.阻止拷贝有两点限制：
 *（1）在C++11之前对象必须有正常的拷贝语义才能放入容器中，禁用拷贝构造的对象无法直接放入容器中，当然你可以使用指针来规避这一点，
 *     但是你又落入了自己管理指针的困境之中（或许使用智能指针可以缓解这一问题）。
 *（2）C++11中存在移动语义，你可以通过移动而不是拷贝把数据放入容器中。拷贝构造函数的另一个应用在于设计模式中的原型模式，
 *     在C++中没有拷贝构造函数，这个模式实现可能比较困难。
 *
 *4.C++的合成构造函数规则：
 *  当派生类调用默认的构造函数、析构函数、拷贝构造函数或赋值运算符时，会先调用基类默认的构造函数、析构函数、拷贝构造函数或赋值运算符，
 *  而基类中拷贝构造函数和赋值运算符均不可用，所以派生类无法进行拷贝行为。同时给NonCopyable类声明默认构造函数和析构函数，
 *  使得在派生类中能够调用基类（NonCopyable）的相应函数来构造/析构基类部分。
 */

#ifndef _NONCOPYABLE_H
#define _NONCOPYABLE_H

class Noncopyable
{
protected:
    Noncopyable(){};           //声明称protected，保证外部不能调用，但子类可以调用
    virtual ~Noncopyable(){}
private:
    Noncopyable(const Noncopyable&);                   //将拷贝构造函数和赋值操作符声明为private，保证不能生成拷贝对象
    Noncopyable& operator =(const Noncopyable&);
};

#endif //_NONCOPYABLE_H